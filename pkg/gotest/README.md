# Go Test Wrapper for OpenShift Tests Extension (OTE)

This package provides a wrapper for standard Go test functions, allowing
them to be integrated into the OpenShift Tests Extension framework as
self-contained binaries, similar to the existing Ginkgo and Cypress
wrappers.

## Features

- **Self-Contained Binaries**: Tests are registered and compiled into the binary
- **No Source Code Required**: Binary can run standalone without access to source
- **Simple Registration**: Register test functions programmatically
- **Pass/Fail/Skip Support**: Properly handles all test outcomes
- **Parallel Execution**: Tests can be run in parallel through the OTE framework

## Usage

### Step 1: Write Your Test Functions

Write your test functions in `.go` files (not `_test.go` since they need to compile into the binary):

```go
// File: test/mytests/basic.go
package mytests

import (
    gt "github.com/openshift-eng/openshift-tests-extension/pkg/gotest"
)

// Simple test
func TestBasicFunctionality(t gt.TestContext) {
    if 1+1 != 2 {
        t.Error("math is broken")
    }
}

// Test with skip
func TestExperimentalFeature(t gt.TestContext) {
    t.Skip("not yet implemented")
}

// Table-driven test
func TestMultipleScenarios(t gt.TestContext) {
    tests := []struct {
        name     string
        input    int
        expected int
    }{
        {"zero", 0, 0},
        {"positive", 5, 10},
    }

    for _, tt := range tests {
        t.Logf("Running test: %s", tt.name)
        result := tt.input * 2
        if result != tt.expected {
            t.Errorf("got %d, want %d", result, tt.expected)
        }
    }
}
```

### Step 2: Generate Test Registry

Use `go generate` to automatically create the test registry:

```go
package mytests

//go:generate go run ../../hack/generate-test-registry/main.go -input . -output generated_tests.go -package mytests -prefix mytests/
```

Then run:

```bash
cd test/mytests
go generate
```

This creates `generated_tests.go`:

```go
// Code generated by generate-test-registry. DO NOT EDIT.

package mytests

import (
    ext "github.com/openshift-eng/openshift-tests-extension/pkg/extension/extensiontests"
    gt "github.com/openshift-eng/openshift-tests-extension/pkg/gotest"
)

var Tests = []gt.Test{
    {
        Name:      "mytests/TestBasicFunctionality",
        Labels:    []string{},
        Lifecycle: ext.LifecycleBlocking,
        TestFunc:  TestBasicFunctionality,
    },
    {
        Name:      "mytests/TestExperimentalFeature",
        Labels:    []string{},
        Lifecycle: ext.LifecycleBlocking,
        TestFunc:  TestExperimentalFeature,
    },
    // ... more tests ...
}
```

**Optional**: Customize labels and lifecycle by manually editing the generated file or creating a wrapper.

### Step 3: Create Your Binary

```go
package main

import (
    "fmt"
    "os"

    "github.com/spf13/cobra"

    "github.com/openshift-eng/openshift-tests-extension/pkg/cmd"
    e "github.com/openshift-eng/openshift-tests-extension/pkg/extension"
    gt "github.com/openshift-eng/openshift-tests-extension/pkg/gotest"

    // Import your test package
    tests "yourmodule/mytests"
)

func main() {
    registry := e.NewRegistry()
    ext := e.NewExtension("openshift", "myextension", "tests")

    ext.AddSuite(e.Suite{
        Name: "myextension/all",
    })

    // Build test specs from registered tests
    specs, err := gt.BuildExtensionTestSpecsFromRegisteredTests(tests.RegisteredTests)
    if err != nil {
        panic(fmt.Sprintf("couldn't build test specs: %+v", err))
    }

    ext.AddSpecs(specs)
    registry.Register(ext)

    root := &cobra.Command{
        Long: "My Test Extension",
    }

    root.AddCommand(cmd.DefaultExtensionCommands(registry)...)

    if err := root.Execute(); err != nil {
        os.Exit(1)
    }
}
```

### Labels and Lifecycle

Labels and lifecycle are specified in the `RegisteredTest` struct:

```go
{
    Name:        "mytests/TestMyFeature",
    Description: "Description of the test",
    Labels:      []string{"sig-testing", "slow"},  // Tags for filtering
    Lifecycle:   ext.LifecycleBlocking,            // or ext.LifecycleInforming
    TestFunc:    TestMyFeature,
}
```

- **Lifecycle Blocking**: Test failures cause the suite to fail (default)
- **Lifecycle Informing**: Test failures don't cause the suite to fail (useful for flaky tests)

### TestContext Interface

Test functions receive a `gt.TestContext` which provides:

```go
type TestContext interface {
    Error(args ...interface{})              // Mark test as failed
    Errorf(format string, args ...interface{})
    Fail()                                  // Mark as failed, continue execution
    FailNow()                               // Mark as failed, stop execution
    Failed() bool                           // Check if test has failed
    Fatal(args ...interface{})              // Log and stop
    Fatalf(format string, args ...interface{})
    Helper()                                // Mark function as test helper
    Log(args ...interface{})                // Log output
    Logf(format string, args ...interface{})
    Name() string                           // Get test name
    Skip(args ...interface{})               // Skip test
    SkipNow()                               // Skip immediately
    Skipf(format string, args ...interface{})
    Skipped() bool                          // Check if test was skipped
}
```

This interface is compatible with `testing.TB`, so most test code works without modification.

## How It Works

1. **Write Tests**: Create test functions with signature `func Test*(t gt.TestContext)`
2. **Generate Registry**: Run `go generate` to auto-create a `Tests` slice
3. **Compilation**: Tests are compiled into the binary (no source code needed at runtime)
4. **Execution**: The OTE framework calls your test functions through the TestContext interface
5. **Result Capture**: Test output and failures are captured and returned as ExtensionTestResult

## Self-Contained Binary

Unlike the traditional `go test` approach, this wrapper produces a self-contained binary:

- ✅ No source code required at runtime
- ✅ Binary can be distributed and run anywhere
- ✅ Tests are part of the binary, like Ginkgo tests
- ✅ Perfect for CI/CD and production test execution

## Organizing Multiple Tests

You can organize tests across multiple files or packages:

```go
// File: mytests/basic_tests.go
var BasicTests = []gt.RegisteredTest{ /* ... */ }

// File: mytests/advanced_tests.go
var AdvancedTests = []gt.RegisteredTest{ /* ... */ }

// File: mytests/all.go
var AllTests = append(append([]gt.RegisteredTest{}, BasicTests...), AdvancedTests...)

// In main.go
specs, err := gt.BuildExtensionTestSpecsFromRegisteredTests(mytests.AllTests)
```

## Commands

Once integrated, your tests support all standard OTE commands:

### List Tests

```bash
./my-test-binary list
```

### Run Specific Test

```bash
./my-test-binary run-test "packagename/TestName"
```

### Run Suite

```bash
./my-test-binary run-suite myextension/all
```

### Get Info

```bash
./my-test-binary info
```

## Comparison with Other Wrappers

### vs. Ginkgo Wrapper

| Feature | Go Test Wrapper | Ginkgo Wrapper |
|---------|----------------|----------------|
| Binary Type | Self-contained | Self-contained |
| Test Style | Traditional test functions | BDD-style (Describe/It) |
| Registration | Manual/explicit | Automatic via import |
| Dependencies | None (standard library) | Requires Ginkgo v2 fork |
| Best For | Simple tests, existing test code | Complex scenarios, behavioral specs |

### vs. Cypress Wrapper

| Feature | Go Test Wrapper | Cypress Wrapper |
|---------|----------------|-----------------|
| Language | Go | JavaScript |
| Binary Type | Self-contained | Requires source + npm |
| Use Case | Unit/integration tests | UI/E2E tests |

## Limitations

1. **Manual Registration**: Tests must be explicitly registered (unlike Ginkgo's automatic registration)
2. **No Subtests**: `t.Run()` is not supported (TestContext doesn't have Run method)
3. **Limited testing.TB Compatibility**: Not all testing.TB methods are available (e.g., no TempDir, Cleanup)

## Example Output

### List Tests
```bash
$ ./gotest-example list
[
  {
    "name": "gotest/TestSimplePass",
    "labels": {},
    "source": "openshift:gotest:example",
    "codeLocations": ["/path/to/test/gotest"],
    "lifecycle": "blocking"
  },
  ...
]
```

### Run Test
```bash
$ ./gotest-example run-test "gotest/TestSimplePass"
[
  {
    "name": "gotest/TestSimplePass",
    "lifecycle": "blocking",
    "duration": 269,
    "result": "passed",
    "output": "=== RUN   TestSimplePass\n--- PASS: TestSimplePass (0.00s)\n..."
  }
]
```

### Run Suite
```bash
$ ./gotest-example run-suite gotest/all
# Runs all discovered tests in parallel
# Returns exit code 0 if all blocking tests pass
# Returns exit code 1 if any blocking test fails
```

## Complete Example

See `cmd/gotest-example/main.go` and `test/gotest/gotest_example_test.go` for a complete working example.

To try it:

```bash
# Build the example
make gotest-example

# List all tests
./gotest-example list | jq -r '.[].name'

# Run all tests
./gotest-example run-suite gotest/all

# Run specific test
./gotest-example run-test "gotest/TestSimplePass"

# Check info
./gotest-example info
```

## Automatic Test Discovery with go generate

The `generate-test-registry` tool automatically discovers test functions and generates the registration code.

### How It Works

1. Add a `go:generate` comment to your package:

```go
//go:generate go run ../../hack/generate-test-registry/main.go -input . -output generated_tests.go -package mytests -prefix mytests/
```

2. Run `go generate`:

```bash
cd test/mytests
go generate
```

3. The tool scans all `.go` files, finds functions matching `func Test*(t gt.TestContext)`, and generates `generated_tests.go` with a `Tests` slice.

4. All tests default to `Lifecycle: Blocking` and empty `Labels`. Edit the generated file to customize.

See [hack/generate-test-registry/README.md](../../hack/generate-test-registry/README.md) for more details.

## Building Your Own

Add to your Makefile:

```makefile
my-test-binary:
	GO_COMPLIANCE_POLICY="exempt_all" go build -ldflags "$(LDFLAGS)" ./cmd/my-test-binary/...
```

Then run:

```bash
make my-test-binary
./my-test-binary list
./my-test-binary run-suite myextension/all
```

