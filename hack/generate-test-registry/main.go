package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

type TestInfo struct {
	Name        string
	PackageName string
}

func main() {
	inputDir := flag.String("input", ".", "Directory to scan for test files")
	outputFile := flag.String("output", "generated_tests.go", "Output file for generated test registry")
	packageName := flag.String("package", "", "Package name (defaults to directory name)")
	testPrefix := flag.String("prefix", "", "Prefix for test names (e.g. 'mypackage/')")
	flag.Parse()

	// Determine package name
	pkgName := *packageName
	if pkgName == "" {
		pkgName = filepath.Base(*inputDir)
	}

	// Find all test functions
	tests, err := findTestFunctions(*inputDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error finding tests: %v\n", err)
		os.Exit(1)
	}

	if len(tests) == 0 {
		fmt.Fprintf(os.Stderr, "No tests found in %s\n", *inputDir)
		os.Exit(1)
	}

	// Sort tests by name for consistency
	sort.Slice(tests, func(i, j int) bool {
		return tests[i].Name < tests[j].Name
	})

	// Generate the output file
	err = generateRegistry(*outputFile, pkgName, tests, *testPrefix)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating registry: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated test registry with %d tests in %s\n", len(tests), *outputFile)
}

func findTestFunctions(dir string) ([]TestInfo, error) {
	var tests []TestInfo

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Only process .go files (but skip generated files)
		if !strings.HasSuffix(path, ".go") {
			return nil
		}
		if strings.HasSuffix(path, "generated_tests.go") {
			return nil
		}

		// Parse the file
		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return fmt.Errorf("failed to parse %s: %v", path, err)
		}

		// Find test functions
		for _, decl := range node.Decls {
			fn, ok := decl.(*ast.FuncDecl)
			if !ok {
				continue
			}

			// Check if function starts with Test
			if !strings.HasPrefix(fn.Name.Name, "Test") {
				continue
			}

			// Check if it has the right signature: func TestXxx(t gt.TestContext)
			if fn.Type.Params == nil || len(fn.Type.Params.List) != 1 {
				continue
			}

			param := fn.Type.Params.List[0]
			if len(param.Names) != 1 {
				continue
			}

			// Check if parameter type is gt.TestContext or gotest.TestContext
			if sel, ok := param.Type.(*ast.SelectorExpr); ok {
				if ident, ok := sel.X.(*ast.Ident); ok {
					if (ident.Name == "gt" || ident.Name == "gotest") && sel.Sel.Name == "TestContext" {
						tests = append(tests, TestInfo{
							Name:        fn.Name.Name,
							PackageName: node.Name.Name,
						})
					}
				}
			}
		}

		return nil
	})

	return tests, err
}

func generateRegistry(outputFile, packageName string, tests []TestInfo, testPrefix string) error {
	tmpl := template.Must(template.New("registry").Parse(`// Code generated by generate-test-registry. DO NOT EDIT.

package {{.PackageName}}

import (
	ext "github.com/openshift-eng/openshift-tests-extension/pkg/extension/extensiontests"
	gt "github.com/openshift-eng/openshift-tests-extension/pkg/gotest"
)

// Tests contains all the tests to be included in the binary
var Tests = []gt.Test{
{{- range .Tests}}
	{
		Name:      "{{$.TestPrefix}}{{.Name}}",
		Labels:    []string{},
		Lifecycle: ext.LifecycleBlocking,
		TestFunc:  {{.Name}},
	},
{{- end}}
}
`))

	f, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer f.Close()

	data := struct {
		PackageName string
		Tests       []TestInfo
		TestPrefix  string
	}{
		PackageName: packageName,
		Tests:       tests,
		TestPrefix:  testPrefix,
	}

	return tmpl.Execute(f, data)
}

